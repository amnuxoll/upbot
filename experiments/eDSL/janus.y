/**
 * robot.y
 *
 * The grammar definition for the UPBOT DSL.
 *
 * @author Fernando Freire
 * @since 04 Aug 2013
 *
 */
%{

#include <stdio.h>
#include <string.h>
#include "janus.h"

/**
 * state
 *
 * A linked list struct that should theoretically make it possible to string
 * multiple states together into a generated C file.
 *
 */
struct state {
    int     transition_count;

    char*   responder;
    char*   responder_mod;

    char*   event;
    char*   event_mod;

    struct  state *next;
};

int state_count;

struct state *janus_state;

%}

/**
 * UNION
 *
 * This union definition allows us to extend the YYLVAL variable that gets
 * thrown around between FLEX and BISON.
 */
%union {
    int ival;   // Integer value that is received from INT_MOD
    char *bval; // String value that is received from BUMP_MOD
    char *dval; // String value that is received from DRIVE_MOD
}

/**
 * TOKENS
 *
 * These are the supported tokens that FLEX is currently catching. In the case
 * of the first three tokens, we are actually capturing input, so we need to
 * specify their type before proceeding.
 *
 */
%token <ival> INT_MOD
%token <bval> BUMP_MOD
%token <dval> DRIVE_MOD

%token STATE_O STATE_C PAREN_O PAREN_C
%token LABEL NOOP BUMP STOP TIME WHEEL
%token CLIFF VWALL TURN SONG DRIVE BLINK
%token STOP_MOD TURN_MOD
%token PAIRED_WITH YIELDS

/* better error messages */
%error-verbose

/* Where should we start parsing? */
%start state_list

%%

state_list
        : state_list state
        | state
        ;

state
        : STATE_O LABEL statement_list STATE_C  {
                                                    state_count++;
                                                }
        ;

statement_list
        : statement
        | statement_list statement
        ;

statement
        : event_list PAIRED_WITH responder_list YIELDS LABEL    {
                                                                    janus_state->transition_count++;
                                                                }
        ;

event_list
        : event
        | PAREN_O event PAREN_C
        | PAREN_O event_list event PAREN_C
        ;

responder_list
        : responder
        | PAREN_O responder PAREN_C
        | PAREN_O responder_list responder PAREN_C
        ;

event
        : BUMP BUMP_MOD {
                            janus_state->event = "eventBump";
                        }
        | TIME INT_MOD  {
                            janus_state->event = "eventTime";
                        }
        | NOOP          {
                            janus_state->event = "eventTrue";
                        }
        ;

responder
        : DRIVE DRIVE_MOD   {
                                if(strcmp($2, "med") == 0) {
                                    janus_state->responder = "respondDriveMed";
                                } else if(strcmp($2, "low") == 0) {
                                    janus_state->responder = "respondDriveLow";
                                } else if(strcmp($2, "high") == 0) {
                                    janus_state->responder = "respondDriveHigh";
                                }
                            }

        | TURN TURN_MOD     {
                                janus_state->responder = "respondTurn";
                            }

        | STOP STOP_MOD     {
                                janus_state->responder = "respondStop";
                            }
        ;

%%

/**
 * main()
 *
 * Responsible for running the yyparse function, which will apply the above
 * grammar definition to the tokenized input returned from FLEX.
 *
 * @param[in] argc The number of arguments passed to main.
 * @param[in] argv An array of arguments passed to main.
 *
 */
int main(int argc, char** argv) {
    janus_state = malloc(sizeof(struct state));
    headerContents();
    yyparse();
    constructER();
}

/**
 * yyerror()
 *
 * This function is called if yyparse encounters an error during the parsing of
 * the input file.
 *
 * @param[in] s The error string generated by BISON.
 *
 */
yyerror(char *s) {
  fprintf(stderr, "error: %s\n", s);
}

/**
 * headerContents()
 *
 * Output a static set of header contents into a header file that will be included
 * in the generated C file from Janus.
 *
 */
void headerContents() {
    FILE* header = fopen("janusER.h", "w");

    fputs("/* This file was generated by the Janus DSL parser. */\n", header);
    fputs("#include \"eventresponder.h\"\n", header);
    fputs("#include \"events.h\"\n", header);
    fputs("#include \"responders.h\"\n", header);
    fputs("#ifndef JANUS_EVENT_RESPONDER\n", header);
    fputs("#define JANUS_EVENT_RESPONDER\n", header);
    fputs("void initializeJanusER(eventResponder* jER);\n", header);
    fputs("void selectNextER(char* erName, eventResponder* myER);\n", header);
    fputs("#endif\n", header);

    fclose(header);
}

/**
 * constructER()
 *
 * Output one (1) state definition with the given transitions found in the janus file.
 * Eventually this function should be able to take the state struct and compose the
 * necessary C code without a lot of this manual printing.
 *
 */
void constructER() {
    printf("\n");
    printf("#include \"janusER.h\"\n");
    printf("void initializeJanusER(eventResponder* jER) {\n");
    printf("  jER->curState = 0;\n");
    printf("  jER->stateCount = %d;\n", state_count);
    printf("  jER->states = malloc(sizeof(state)*1);\n");
    printf("    jER->states[0].count = %d;\n", janus_state->transition_count);
    printf("    jER->states[0].clockTime = 0;\n");
    printf("    jER->states[0].transitions = malloc(sizeof(transition) * %d);\n", janus_state->transition_count);
    printf("      jER->states[0].transitions[0].e = %s;\n", janus_state->event);
    printf("      jER->states[0].transitions[0].r = %s;\n", janus_state->responder);
    printf("      jER->states[0].transitions[0].n = 0;\n");
    printf("}\n");
}
